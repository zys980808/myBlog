{"meta":{"title":"Jeff的博客","subtitle":null,"description":null,"author":"Jeff","url":"http://zys980808.github.io"},"pages":[],"posts":[{"title":"Linux-Quick-Start.md","slug":"Linux/Linux-Quick-Start-md","date":"2020-04-19T06:54:00.000Z","updated":"2020-04-19T10:40:36.247Z","comments":true,"path":"2020/04/19/Linux/Linux-Quick-Start-md/","link":"","permalink":"http://zys980808.github.io/2020/04/19/Linux/Linux-Quick-Start-md/","excerpt":"Linux快速入门个人食用的Linux快速入门小手册。 资料 Linux命令大全(手册)","text":"Linux快速入门个人食用的Linux快速入门小手册。 资料 Linux命令大全(手册) Shell终端Linux系统的内核负责完成对硬件资源的分配、调度等管理任务。Shell将用户的基于计算机的命令转述给内核执行。 6个预设终端，使用快捷键[Ctrl] + [Alt] + [F1]~[F6]切换 ↑ ↓ 历史指令 Tab补全 批处理脚本 环境变量 重定向 … 关于更多的内容会在后面的Bash特性讲到，这里简单带过 帮助 在只记得部分命令关键字的场合，我们可通过man -k来搜索； 需要知道某个命令的简要说明，可以使用 whatis；而更详细的介绍，则可用info命令； 查看命令在哪个位置，我们需要使用which； 而对于命令的具体参数及使用方法，我们需要用到强大的man； 看用法，用man；更细致的说明和介绍要用info man使用man查看手册是非常重要的学习技能， man # keyword 可以指定对应的手册序号 man -f keyword 浏览不同手册下的该条目信息 man -k keyword 进行内容检索 序号 代表内容 1 使用者在shell环境中可以执行的指令或可执行程序；比如ls 2 系统核心可调用的函数与工具等 3 一些常用的函数(function)与函数库(library)，大部分为C的函数库(libc)；比如printf函数 4 设备的说明，通常在/dev下的档案 5 配置文件的格式；比如/etc/passwd 6 游戏(games) 7 惯例与协定等，例如Linux文件系统、网络协议、ASCII code等等的说明 8 系统管理员可用的管理指令 9 跟kernel有关的文件 比如man fork会显示fork(2)；在前期的学习 1, 5, 8 相对重要一些；到后面学APUE估计就经常要查 2, 3, 9 了 查阅文档时可以进行的一些操作： 按键 进行工作 空白键 向下翻一页 [Page Down] 向下翻一页 [Page Up] 向上翻一页 [Home] 去到第一页 [End] 去到最后一页 /string 向『下』搜寻string 这个字串 ?string 向『上』搜寻string 这个字串 n, N 利用/ 或? 来搜寻字串时，可以用n 来继续下一个搜寻(不论是/ 或?) ，可以利用N 来进行『反向』搜寻 q 结束这次的man page info基本上，info与man的用途其实差不多，但info内容拆分成可跳转的节点，形成树状的结构。 U 返回上层父节点（目录） N 下一个节点 P 上一个节点 Enter 进入超链接 h 求助 目录命令cd切换目录 cd - = cd ${OLDPWD} 访问上一次所在目录 pwd查看当前目录 即 echo ${PWD} ls展示文件夹文件 -R 递归显示 -d 仅查看目录自身（管道下好用） -l 长列表，详细信息 -h 文件大小加单位 命令相关which定位指令/别名的位置 --skip-alias 可以跳过别名(??) whereis定位一个命令的 bin, src, man -b 只看binary -m 只看manual -s 只看src alias查看别名列表 定义别名，alias NAME=VALUE，只对当前shell进程有效 unalias 撤销别名 history查看历史命令 登出也会保存到文件中 可以通过设置环境变量定制history $HISTSIZE 命令历史条数 $HISTFILE: 持久保存命令历史的文件位置 $HISTFILESIZE: 上述文件大小 $HISTCONTROL: 控制命令历史的记录方式 ignoredups: 忽略重复的命令 ignorespace: 忽略空白字符开头的命令 ignoreboth: 两者同时生效 !#: 再一次执行 history 中的命令 !STRING: 执行最近的以STRING开头的命令 ESC + &#39;.&#39; 或 ALT+ &#39;.&#39;: 上一条命令的最后一个参数，等同于 !$ 时间命令date显示或设置系统时钟；系统时钟是开机获取完硬件时间后由CPU自己跳的时间 自定义显示格式: date +&quot;%Y-%m-%d-%H-%M-%S&quot;(更多的格式可以自行查帮助); %j 可看是一年中的第几天 设定日期时间: date [MMDDhhmm[[CC]YY][.ss]] 另一个设置日期时间的方法: date -s &quot;20170901 8:30:00&quot; hwclock显示或设定硬件时钟；硬件时钟是BIOS供电维护的时间 -s --hctosys: 硬件时间写入到系统时间 -w --systohc: 系统时间写入到硬件时间 cal日历 cal [[month] year] 其他常用指令file查看文件类型 type查看命令类型，内置or外部可执行文件 cat输出文本文件内容 -n 加行数 echo输出指定字符串 -e 使转义符生效 (需要引号) “” 弱引用，替换 $ 变量; 例如echo &quot;${PWD}&quot; ‘’ 强引用，不替换 $ 变量 shutdown关机 shutdown [OPTIONS…] [hh:mm/+m] [wall msg] shutdown now = shutdown +0 -r = reboot -p = poweroff -h = halt -c 取消 wall向所有用户发出信息 sync将内存中暂存的信息写入硬盘， good practice: 定时和关机前sync一下 who查看当前登录用户的信息 -r 运行级别？ w 强化版 who，还显示运行状况 bc计算器、单位换算器(?) +,-,*,/,^,% scale = # 设置显示小数点，默认为0位","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zys980808.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zys980808.github.io/tags/Linux/"}]},{"title":"edge type","slug":"Algorithm/graph-edge-type","date":"2018-11-26T07:02:26.000Z","updated":"2020-04-19T06:50:28.324Z","comments":true,"path":"2018/11/26/Algorithm/graph-edge-type/","link":"","permalink":"http://zys980808.github.io/2018/11/26/Algorithm/graph-edge-type/","excerpt":"有向图边的类型有向图边有如下几个类型： tree edge 树边 foward edge 前向边 back edge 回边 cross edge 横跨边 一张图即可解释：","text":"有向图边的类型有向图边有如下几个类型： tree edge 树边 foward edge 前向边 back edge 回边 cross edge 横跨边 一张图即可解释： 判断有向图边的类型在DFS的过程中，可以直接用pre, post 值来判断；当然首先得知道如何计算 pre, post 值，这同样可以用一张图来解释（该图数对为 pre,post）： 如果一个点pre和post值不存在，说明该点未被访问过，是一个 树边 （例如图中F-&gt;G) 如果 pre(u) &lt; pre(v) &lt; post(v) &lt; post(u)，说明 u 肯定 v 的祖先 若有 v-&gt;u， 则该边是一个 回边；（例如图中F-&gt;B) 若有 u-&gt;v, 且显然此时pre(v)和post(v)都存在，不可能是树边，则该边是 前向边 （例如图中E-&gt;G) 对于 横跨边，已经是分属两条不同的深搜路径，所以必然的，两个点的(pre,post)区间没有重叠（例如图中 D-&gt;H 可以总结为下图： 应用判断有向图是否有圈等价于判断图中是否有 回边 进行拓扑排序首先要知道什么是拓扑排序：拓扑排序就是将结点依次排序，使得图内的边都是从该序列前面的点流向后面的点（显然前提是这个图不能有环） 例：穿衣服问题，见下图。 正如图中所示，只要按Post值倒序就可以了 当然这题还有另外的解法：不断从图中删去in-degree为0的点（source）","categories":[{"name":"算法","slug":"算法","permalink":"http://zys980808.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zys980808.github.io/tags/算法/"},{"name":"图论","slug":"图论","permalink":"http://zys980808.github.io/tags/图论/"}]},{"title":"强连通分量","slug":"Algorithm/graph-scc","date":"2018-11-26T06:56:31.000Z","updated":"2020-04-19T06:50:28.331Z","comments":true,"path":"2018/11/26/Algorithm/graph-scc/","link":"","permalink":"http://zys980808.github.io/2018/11/26/Algorithm/graph-scc/","excerpt":"定义Definition: A strongly connected component (SCC) of a directed graph G = (V, E) is a maximal set of vertices C ⊆ V such that every pair of vertices u and v in C are reachable from each other. 翻译过来就是，把一个有向图划分成尽可能大的几个集合，集合内的结点两两互相都可达，这样的每一个“集合”就是一个强连通分量","text":"定义Definition: A strongly connected component (SCC) of a directed graph G = (V, E) is a maximal set of vertices C ⊆ V such that every pair of vertices u and v in C are reachable from each other. 翻译过来就是，把一个有向图划分成尽可能大的几个集合，集合内的结点两两互相都可达，这样的每一个“集合”就是一个强连通分量 求解过程分析 求解一个有向图的强连通分量的算法不是一蹴而就的，下面就叙述一下这个算法逐步形成的过程 将强连通分量都“缩圈”缩成一个点，得到的图是DAG（有向无环图） —— 任何一个有向图都是其 强连通分量 组成的DAG 一个DAG，一定会有Sink（入度为0的点）和Source（出度为0的点） 如果能从Sink联通量里面任意一个点开始DFS，就可以求出这个Sink联通量，因为它跑不出去。 然后删去这个联通量，DFS树仍有叶子——就是仍有Sink，重复上述操作 可是问题就在于：并无法找到Sink联通量里的一个点。那该怎么办呢？ 虽然没法找到Sink联通量，但我们可以找得到Source：在完整DFS过程以后，Post值最大的就一定在Source联通量内： 假设从Source内的点开始DFS，显然Post最大的就在Source内（Root） 假设不从Source内的点开始DFS，Source是到不了的；后面必然又要从Source内的点再次DFS，导致Post值最大 但找到Source也没有用啊，从Source内的一点开始DFS，肯定会跑出去，那有什么用呢？ 把边反向，Source就变成了Sink，而且联通的性质是不变的——强联通量还是那些强联通量 这样就可以从Post最大的值开始DFS，找出第一个强联通量，并且从图中删去 更棒的是，删去第一个强联通量以后，现在Post最大的就是删后图的Sink值，这样就可以不断重复前面的步骤 求解步骤总结 如果完整地看完了上面，下面的求解步骤可以直接忽略的啦 进行DFS，求出每个结点的Post值，存入优先队列 将有向图边反向 $G {\\rightarrow} G^T$ 从Post值最高的点开始DFS，并将DFS所得的点存入一个集合，形成一个强连通分量；同时将这些点从图中删去 重复第三步，直到所有联通量都形成 复杂度分析 第一次DFS求Post值并放入优先队列：$O(V+E) + O(log_2V) = O(V+E)$ 将有向图边反向：$O(V+E)$ 求强联通量的过程，实际上加起来就是一次完整的DFS而已：$O(V+E)$ 总复杂度$O(V+E)$","categories":[{"name":"算法","slug":"算法","permalink":"http://zys980808.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://zys980808.github.io/tags/算法/"},{"name":"图论","slug":"图论","permalink":"http://zys980808.github.io/tags/图论/"}]},{"title":"面试经历-字节跳动后台开发(基础架构)实习岗","slug":"Interview-ByteDance","date":"2018-11-26T05:47:10.000Z","updated":"2020-04-19T06:50:28.336Z","comments":true,"path":"2018/11/26/Interview-ByteDance/","link":"","permalink":"http://zys980808.github.io/2018/11/26/Interview-ByteDance/","excerpt":"昨天下午尝试了第一次视频面试，面试的岗位是字节跳动的[后台开发-基础架构]实习岗，由于我本身的技术的确是远远没有达到岗位的要求，所以这一次的面试也只是抱着试一试的态度，了解一下面试的流程，积累一些经验，同时通过面试进一步了解自己应该努力的方向。","text":"昨天下午尝试了第一次视频面试，面试的岗位是字节跳动的[后台开发-基础架构]实习岗，由于我本身的技术的确是远远没有达到岗位的要求，所以这一次的面试也只是抱着试一试的态度，了解一下面试的流程，积累一些经验，同时通过面试进一步了解自己应该努力的方向。 时间定在了周日下午的四点，直到面试前都没有加上HR的微信，所以在面试前心中还是有种“我要被鸽了”的感觉。点开通知邮件发给我的面试链接以后，点开展示的就是牛客网的面试系统界面: 四点过了两分钟，面试官就上线了，是个很有亲和力的中年男子。此时我还是很紧张的，毕竟是第一次参加正经的面试，所以谈吐都有些不自然了。调整视频连接耽误了一小段时间。 编程面试官看了看我的简历，上面有一项是“熟悉Go语言编程”；我听到他提起这个心里就凉了一半：其实自己对于Go语言也借由本学期的服务计算课进行了个入门而已，远算不上熟悉。然后他说有一道题特别适合用Go来编程，就出给我做了: 先定义了一个read函数，这个函数就是一个Socket接口，每次会读数据入缓冲区；然后要我写一个readLine函数，按行输出Socket读的数据，他一开始先给了我两个提示： read是会阻塞的 每次read得到的数据有可能有换行符\\n，有可能没有，也有可能会有多个 这是面试官给出的函数定义: // read: socket api // - fd: socket 的文件fd // - buf: 读入缓冲区 // - N: 最大数据大小 func read(fd int, buf []byte, N int) int { } 听完题后我整个人就很慌了，因为心里总有股声音觉得自己不会。而实际上我也的确对Go不熟悉，很多类似append, channel 这样的操作还需要查自己或别人的博客去写。 虽然慌的一匹，但总归还是有一点思路（现在想来这也不过就是一道生产者、消费者的问题），中间面试官提示我用channel去做这一道题，但我并没有用过所以短暂思考后也放弃了这个思路。 最后用一个循环调用read的方法完成了这道题，用last变量来存储上一次调用read所剩下的内容： type Read struct { fd int // socket fd N int // max size per line last []byte // last read remained } func (r Read) readLine() string { var buf []byte for read(r.fd, buf, r.N) != 0 { for i := 0; i &lt; buf.size(); i++ { if buf[i] == &#39;\\n&#39; { temp := append(last, buf[:i]...) r.last = buf[i+1:] return temp } } } return &quot;&quot; } 这中间有几个严重的逻辑错误，都是面试官提出来然后我才能反应过来并迅速修正： 如果某次read得到了多行，那么last存储的数据就会是多行的，代码没有考虑这个问题。解决方案我也立马能想出来：在执行循环调用read之前先检查last是否为空，不为空就遍历一遍看看是否有一行存在，有则返回第一行并对last进行切割 如果某次read没有换行，这份代码并没有将这次读取的数据保存。显然解决方案就是在每次循环的末尾增加一个append(last, buf...) 这也体现出我的思维是很不严谨的，然后代码能力也偏弱。我在以往做算法题的时候就很依赖提交，通过提交去检查自己的代码有没有问题，这样在考试的时候就会体现出我这样效率其实很低，而且长期的依赖也导致了自己基本的Debug能力有所降低。 在编程测试结束的时候，面试官告诉我简历不能给面试带来信息不对称，比如刚入门Go语言就不应该写成熟悉；也真是令人汗颜。自己的简历的确有着不少的水分，需要重新修改一番。 后阶段面试后阶段面试就更加能显现我简历的水分了，面试官看到我在简历里写了我在做MIT的6.828的实验，他想要从这里展开。到这里我就不得不和盘托出其实我只做了这个系列实验的Lab1，然后考虑到学这个又要去学x86编程，耗费时间有点多然后就搁置了。听到这里其实面试官已经基本宣告面试fail了。他告诉我这个部门是负责存储的，所以对算法或者某一后台领域的知识会要求很高，所以希望我可以明确一个方向，回去好好修炼再去考虑面试的事情。他还推荐我可以去看CMU的存储课程。另外，他还说我可以考虑面试一下后台业务开发的岗位，链接在面试通知邮件里也可以找到。 后记这次面试也就这样在不安中结束了。的确这次就是抱着来试试的态度进行面试，所以结果不如意倒也正常。面试时间虽然只有短短的一个多小时，但也还是了解到了自己很多的缺陷：代码能力亟待提高，需要专精一个后台的方向（目前我想做的是网络编程），另外基础课程的知识也非常重要，如果有时间得捡回6.828，再加一些存储的课程。","categories":[{"name":"其他","slug":"其他","permalink":"http://zys980808.github.io/categories/其他/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://zys980808.github.io/tags/面试/"},{"name":"Go","slug":"Go","permalink":"http://zys980808.github.io/tags/Go/"}]},{"title":"VirtualBox安装 WinXP+CentOS双系统","slug":"Linux/VitualBox-Double-System","date":"2018-11-24T06:11:22.000Z","updated":"2020-04-19T06:50:28.341Z","comments":true,"path":"2018/11/24/Linux/VitualBox-Double-System/","link":"","permalink":"http://zys980808.github.io/2018/11/24/Linux/VitualBox-Double-System/","excerpt":"建议在开始之前，先在这里学习分区和开机的知识，然后按照这个步骤把CentOS单系统安装成功之后，再来看这里。 参考资料 鸟哥Linux私房菜 - 多重开机安装流程与管理 Grub2配置文件详解","text":"建议在开始之前，先在这里学习分区和开机的知识，然后按照这个步骤把CentOS单系统安装成功之后，再来看这里。 参考资料 鸟哥Linux私房菜 - 多重开机安装流程与管理 Grub2配置文件详解 Let’s Go采用的是先装 CentOS, 再安装Windows的过程，体验一下 “救援” 被Windows覆盖的MBR的过程 下载XP ISO 安装版，有些版本是所谓 装机版 是不能在Virtual Box跑的，它需要在Windows下打开来运行；我们需要的是ISO映像 这个就可以 CentOS-7 minimal, 官网下载即可 新建虚拟硬盘 这一步很关键 由于XP系统只能识别IDE硬盘，因此在新建系统时如果选择Ubuntu，Win10之类的都会自动分配一个SATA硬盘，这会导致WindowsXP无法识别，从而安装失败。 选择Linux-&gt;其他Linux系统则会分配IDE接口的硬盘。另外，直接选择XP系统会导致CentOS中途无法安装，原因暂时不明 还需继续研究 使用CentOS分区并安装CentOS当然WindowsXP也能进行分区，只不过界面和功能来说还是CentOS更胜一筹；详细的步骤跟着 鸟哥的教程就行了。当然博主的分区规划和鸟哥的略有不同，如下所示： 1M ~ 15G : 主要分区1，用于安装CentOS (sda1) 15G ~ 30G : 主要分区2，用于安装WindowsXP (sda2) 30G ~ 40G : 扩展分区 (sda3) 30G ~ 38G ：逻辑分区1，用于windows和cent共享数据 (sda5) 注意到这里从5开始，因为如前所述1~4分给了primary和extended 38G ~ 40G : 逻辑分区2，用于换页，增强内存功能 (sda6) 安装WindowsXP重新设置一下启动的ISO镜像，选择WindowsXP镜像启动，然后安装，注意别安装错了（当然如果不小心点了CentOS的系统盘会有提示上面装了系统） 安装完以后，虚拟硬盘的MBR就被WindowsXP的boot loader “霸道”地覆盖了，重启就只能进入WindowsXP系统 救援MBR内的Boot Loader此时我们需要替换MBR的boot loader，不能再让XP占用下去了！网上很多建议装双系统是先装Windows再装Linux，是因为很多Linux版本自带了一个强大的 boot loader - grub2, 它可以实现多重引导（其实本质上就是引导到某个分区的booting section上而已） 现在在MBR被覆盖的情况下，我们仍然能通过CentOS的安装程序进行“救援”：关机，切换CentOS的ISO镜像，然后按照鸟哥的教程进行救援 Grub2设置鸟哥的教程里有一部分对Grub2的设置，乍一看还是蛮困扰的，幸亏看了这一片教程，我知道了set root=&#39;(hd0,3)&#39;指的是第一块硬盘内的第三个主要分区；而博主的分区规划是把Windows安装在第二个主要分区，因此改成set root=&#39;(hd0,2)即可，注意这里格式严格不能有多余空格哦！ 成功！然后重启，就会发现 Grub2 多了一个WindowsXP，截图留念： 当然Windows也启动成功了： 如有任何问题，可发邮件至 ``zys980808@126.com 告知我，感激不尽！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zys980808.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zys980808.github.io/tags/Linux/"}]},{"title":"Go Learning","slug":"Go-Learning","date":"2018-11-24T03:58:17.000Z","updated":"2020-04-19T13:14:43.824Z","comments":true,"path":"2018/11/24/Go-Learning/","link":"","permalink":"http://zys980808.github.io/2018/11/24/Go-Learning/","excerpt":"HelloWorld 基础 包 函数 变量 控制语句 指针 结构体 数组和切片 映射 函数值 函数闭包 方法和接口 方法 接口 HelloWorldpackage main /* Every Go program is made up of packages. Programs start running in package main. */ import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello, 世界&quot;) }","text":"HelloWorld 基础 包 函数 变量 控制语句 指针 结构体 数组和切片 映射 函数值 函数闭包 方法和接口 方法 接口 HelloWorldpackage main /* Every Go program is made up of packages. Programs start running in package main. */ import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello, 世界&quot;) } 基础包按照约定，包名与导入路径的最后一个元素一致。例如：”math/rand”下的包源码均以 package rand 语句开始 导入一个包 import &quot;fmt&quot; 导入多个包 import ( &quot;fmt&quot; &quot;math/rand&quot; ) import &quot;fmt&quot; import &quot;math&quot; 包中大写为“导出” fmt.Println(math.pi) //报错 fmt.Println(math.Pi) //正确 函数简单的例子： package main import &quot;fmt&quot; /* - variable type: after name - return value type : after parameters */ func add(x int, y int) int { return x + y } func main() { fmt.Println(add(42, 13)) } 相同类型形参可省略一个,例如上面 x int, y int 可写作 x, y int 返回值可为多个 func swap(x, y string) (string, string) { return y, x } func main() { a, b := swap(&quot;hello&quot;, &quot;world&quot;) //简洁赋值，等价于var a, b string = swap(...) fmt.Println(a, b) } 命名返回值，直接返回这些命名；长函数会影响可读性 func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } 变量又是一个例子 package main import &quot;fmt&quot; var c, python, java bool func main() { var i int fmt.Println(i, c, python, java) } /* 输出结果： 0 false false false 看来是有默认初始化的过程 */ 基本类型 bool //1 byte string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr /* 其中，int, uint 和 uintptr（尚未知道用处）在32位系统上为32位(4bytes)宽，64-&gt;64。需要整数时尽量使用int */ byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 //注意这里没有单纯的float了 complex64 complex128 多个变量同时赋值 var i, j int = 1, 2 var c, python, java = true, false, &quot;no!&quot; //省略类型，自动从值获取 简洁赋值语句；不能在函数外使用（函数外每个语句必须以关键字开始，如var, func） k := 3 //等价于 var k = 3 语法块变量声明 var ( ToBe bool = true MaxInt uint64 = 1&lt;&lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) 默认初始化值 func main() { var i int var f float64 var b bool var s string fmt.Printf(&quot;%v %v %v %q\\n&quot;, i, f, b, s) } /* 输出结果 0 0 false &quot;&quot; */ 类型转换：和C++类似，但不存在隐式转换 i := 42PP f := float64(i) u := uint(f) //下面会报错 i := 42 var f float64 = i 常量const关键字，不能用:=赋值 const World = &quot;世界&quot; 控制语句Go中循环结构只有 for; for无小括号，但一定要有大括号 sum := 0 for i := 0; i &lt; 10; i++ { sum += i } fmt.Println(sum) for内三个语句都是optional（可作while语句） for ;sum&lt;1000;{} for sum&lt;1000 {} //分号再去掉，形如while for {} //无限循环 条件语句，也是无需小括号，必须大括号 if x &lt; 0 {} if条件判断前可执行一个简单语句, 该语句声明的变量仅在if内 if v := math.Pow(x, n); v &lt; lim { return v } 练习 - 利用牛顿法实现平方根函数 package main import ( &quot;fmt&quot; &quot;math&quot; ) func Sqrt(x float64) float64{ z := 1.0 for math.Abs(z*z - x) &gt; 1e-15{ z -= (z*z - x) / (2*z) } return z } func main(){ fmt.Println(Sqrt(2)) fmt.Println(math.Sqrt(2)) } switch 语句 不需要break，只会运行选中的case 可通过在结尾加 fallthrough 语句延续分支 case无需为常量，取值不必为整数 fmt.Print(&quot;Go runs on &quot;) switch os := runtime.GOOS; os { case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.&quot;, os) } switch 可以不带条件（等价于switch(true))，可当做if then else结构，更加清晰 t := time.Now() switch { case t.Hour() &lt; 12: fmt.Println(&quot;Good morning!&quot;) case t.Hour() &lt; 17: fmt.Println(&quot;Good afternoon.&quot;) default: fmt.Println(&quot;Good evening.&quot;) } defer，在外层函数返回后执行，其实参会立即求值（压入栈中） func main() { fmt.Println(&quot;counting&quot;) for i := 0; i &lt; 10; i++ { defer fmt.Println(i) } fmt.Println(&quot;done&quot;) } /* 输出结果： counting done 9 8 ... 0 */ 指针指针零值为nil,声明如下： var p *int &amp; * 操作和 C比较类似，但没有指针运算 //&amp;操作 i := 42 var p *int = &amp;i //*操作 fmt.Println(*p) *p = 21 结构体简单例子 type Vertex struct { X int Y int } func main() { fmt.Println(Vertex{1, 2}) //注意其赋值使用大括号 } 通过名字赋值 v1 = Vertex{1, 2} v2 = Vertex{X: 1} //v2.Y = 0 点号访问成员 v := Vertex{1, 2} v.X = 4 fmt.Println(v.X) 指针访问结构体，(*p).X 等价于 p.X v := Vertex{1, 2} p := &amp;v (*p).X = 1e9 p.X = 1e9 fmt.Println(v) 数组和切片数组例子，大小需为常数 func main() { var a [2]string a[0] = &quot;Hello&quot; a[1] = &quot;World&quot; fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int{2, 3, 5, 7, 11, 13} fmt.Println(primes) } 切片很常用 左闭右开 就像数组的局部引用，本身不存数据 上下界可忽略（下界默认0，上界默认数组/切片长度） func main() { primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] fmt.Println(s) } /* 输出结果 [3, 5, 7] */ 值得注意的是，这是一个数组： [3]bool{true, true, false} 而这创建了同样的数组，再构建了它的切片 []bool{true, true, false} 结构体和切片结合的例子 s := []struct { i int b bool }{ {2, true}, {3, false}, {5, true}, {7, true}, {11, false}, {13, true}, } 切片的长度：包含的元素个数切片的容量：从它包含的第一个元素开始，到其底层数组末尾的个数（倒是暂时不懂有什么用） s := []int{2, 3, 5, 7, 11, 13} len(s) //6 cap(s) //6 切片空 - nil var s []int fmt.Println(s, len(s), cap(s)) if s == nil { fmt.Println(&quot;nil!&quot;) } 用make创建切片 - 相当于动态创建数组，初始值都为0 a := make([]int, 5) // len(a)=5 b := make([]int, 0, 5) // len(b)=0, cap(b)=5 切片中的切片以及修改的例子 // Create a tic-tac-toe board. board := [][]string{ []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;}, []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;}, []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;}, } // The players take turns. board[0][0] = &quot;X&quot; board[2][2] = &quot;O&quot; board[1][2] = &quot;X&quot; board[1][0] = &quot;O&quot; board[0][2] = &quot;X&quot; // modify the first line (by myself) board[0] = board[0][0:1] board[0] = board[0][:cap(board[0])] 向切片追加元素，注意：这个操作会导致底层数组被挤占，如果cap不够，会分配一个更大的数组 var k = [5]int{1,2,3,4,5} //k: [1 2 3 4 5] m := k[:3] //m: [1 2 3] m = append(m, 200) //m: [1 2 3 200]; k: [1 2 3 200 5] m = append(m, 300) //m/k: [1 2 3 200 300] m = append(m, 400) //m: [1 2 3 200 300 400]; k: [1 2 3 200 300] var k = [5]int{1,2,3,4,5} //k: [1 2 3 4 5] m := k[:3] //m: [1 2 3] m = append(m, 200, 300, 400) //m: [1 2 3 200 300 400] //k: [1 2 3 4 5] Range遍历切片 var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} func main() { //index + value for i, v := range pow { fmt.Printf(&quot;2**%d = %d\\n&quot;, i, v) } //只有index (i) for i := range pow { pow[i] = 1 &lt;&lt; uint(i) // == 2**i } //只有value(value), index用_省略掉 for _, value := range pow { fmt.Printf(&quot;%d\\n&quot;, value) } } Slice 练习 —— 构造给定长度的二维数组并绘图 package main import &quot;golang.org/x/tour/pic&quot; func Pic(dx, dy int) [][]uint8 { result := [][]uint8{} for y := 0; y &lt; dy; y++ { temp := []uint8{} for x := 0; x &lt; dx; x++{ temp = append(temp,uint8((x+y)/2)) } result = append(result, temp) } return result } func main() { pic.Show(Pic) } 映射一个例子 —— 基本类型 k := make(map[string]int) k[&quot;hello&quot;] = 3 fmt.Println(k[&quot;hello&quot;]) 另一个例子 —— 结构体 type Vertex struct { Lat, Long float64 Short float64 } func main() { m := make(map[string]Vertex) m[&quot;Bell Labs&quot;] = Vertex{1,2,3} fmt.Println(m[&quot;Bell Labs&quot;]) } 直接初始化 type Vertex struct { Lat, Long float64 } var m = map[string]Vertex{ &quot;Bell Labs&quot;: Vertex{ 40.68433, -74.39967, }, &quot;Google&quot;: Vertex{ 37.42202, -122.08408, }, //倒也诡异，这里的&quot;,&quot;不能省略 } //简化 var m = map[string]Vertex{ &quot;Bell Labs&quot;: {40.68433, -74.39967}, &quot;Google&quot;: {37.42202, -122.08408}, } 对映射的修改 //在映射 m 中插入或修改元素： m[key] = elem //获取元素： /* 如元素不存在，则返回该元素类型的零值： 例如 int 返回 0, string 返回 &quot;&quot; */ elem := m[key] //获取并检测元素是否存在 elem, ok := m[key] //只检测元素是否存在 _, ok := m[key] //删除元素： delete(m, key) 自创的和if复合使用 if _,ok:=m[&quot;Answer&quot;];ok==true{} 练习：单词检测 package main import ( &quot;golang.org/x/tour/wc&quot; &quot;strings&quot; ) func WordCount(s string) map[string]int { aMap := map[string]int{} aArray := strings.Fields(s) for _,v := range aArray{ aMap[v]++; } return aMap } func main() { wc.Test(WordCount) } 函数值package main import ( &quot;fmt&quot; &quot;math&quot; ) //作为形式参数 func compute(fn func(float64, float64) float64) float64 { return fn(3, 4) } func main() { hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(5, 12)) //作为实际参数 fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow)) } 函数闭包函数闭包指的是这样的“函数值”：该函数值代表的函数使用了函数体外（非全局）的函数；这样就使得这个函数某种意义上来说“附于”这个/这些变量（有种对象的感觉了，只不过这个对象只有一个方法） /*注意这里 adder 并不是一个函数闭包，adder()才是*/ func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { pos:= adder() fmt.Println(pos(1)) fmt.Println(pos(100)) } 练习：斐波那契数列 func fibonacci() func() int { former := 0 latter := 1 return func() int { temp := former temp2 := latter latter += former former = temp2 return temp } } func main() { f := fibonacci() for i := 0; i &lt; 10; i++ { fmt.Println(f()) } } 方法和接口方法Go 没有类。不过你可以为结构体类型定义方法。方法就是一类带特殊的 接收者 参数的函数。 打个栗子 import ( &quot;fmt&quot; &quot;math&quot; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } 为非结构体声明方法 type MyFloat float64 //直接为float64声明方法是非法的，因为它是包外的 func (f MyFloat) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f) } 指针接收者：值得注意的是，如果用值接收者的话，方法是无法对这个接收者——天..还是叫对象吧——方法是无法对这个对象进行修改的，而指针接收者可以。 因此显然是指针接收者更为常用（我认为，要保护数据的时候就最好不用指针） func (v *Vertex) Scale(f float64) { //如果不是*Vertex而是Vertex,这里修改对原对象无效 v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} v.Scale(10) fmt.Println(v.Abs()) } 使用指针接收者时，实际参数无论是对象还是对象的指针，最终都会转化为指针传给函数(而单纯的函数是做不到这一点的，是否指针很严格) func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} v.Scale(2) p := &amp;Vertex{3, 4} p.Scale(2) fmt.Println(v, p) //可以看到由于指针的重定向，两个方式调用方法起到了同样的效果 } 同样地，在方法声明里这样 func (v Vertex) Scale(f float64) 实参也是既可以是指针也可以是值，当然其区别就在于这种声明无法修改对象的值； 总而言之，方法是否能修改对象，要看函数声明的形参，和实参没有关系 接口接口类型的变量可以保存任何实现了这些方法的值 一个例子： type Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat 实现了 Abser a = &amp;v // a *Vertex 实现了 Abser // 下面一行，v 是一个 Vertex（而不是 *Vertex） // 所以没有实现 Abser。 //a = v fmt.Println(a.Abs()) } type MyFloat float64 func (f MyFloat) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f) } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } 接口值也是一个对象，包含了具体对象的值以及它的类型，可以用printf输出；未赋值的接口值其对象值和类型都为&lt;nil&gt; type I interface { M() } type T struct { S string } func (t T) M() { fmt.Println(t.S) } func main() { var i I i = T{&quot;Hello&quot;} describe(i) i.M() fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i) } /* 结果：({Hello}, main.T) */ 如果将某个类型的nil对象赋予某个接口，方法依然会被调用 var t *T i = t fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i) i.M() /* 输出(&lt;nil&gt;, *main.T), 但M方法仍然会被调用 */ 对nil接口（注意不是和上面的nil对象值不同，这里是连类型都是nil）调用方法会panic var i I i.M() //报错 空接口的妙用：可以保存任意类型的值！（怎么有种Javascript的感觉了） var i interface{} i = 42 i = &quot;hello&quot; 类型断言：判断接口是不是某个类型，并且赋值 var i interface{} = &quot;hello&quot; //string 类型 /* 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true */ s, ok := i.(string) fmt.Println(s, ok) /* 若 i 保存的不是一个 T，ok 将为 false 而 t 将为 T 类型的零值 */ f, ok := i.(float64) fmt.Println(f, ok) /* 不是T，又没有OK =&gt; panic */ f = i.(float64) fmt.Println(f) 接口类型选择(switch) switch v := i.(type) { case int: fmt.Printf(&quot;Twice %v is %v\\n&quot;, v, v*2) case string: fmt.Printf(&quot;%q is %v bytes long\\n&quot;, v, len(v)) default: fmt.Printf(&quot;I don&#39;t know about type %T!\\n&quot;, v) } Stringer类型，在fmt中的，是最普遍的接口之一。比如一个Print一个对象，默认会输出对象数据，但可以通过实现 String()方法改变输出 type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age) } func main() { a := Person{&quot;Arthur Dent&quot;, 42} fmt.Println(a) } /* 当前输出： Arthur Dent (42 years) 如果不实现String()方法：{Arthur Dent 42} */ 练习：输出IP地址。用到了fmt.Sprintf package main import &quot;fmt&quot; type IPAddr [4]byte // TODO: Add a &quot;String() string&quot; method to IPAddr func (i IPAddr) String() string{ var result string result = fmt.Sprintf(&quot;%v.%v.%v.%v&quot;,i[0],i[1],i[2],i[3]) return result } func main() { hosts := map[string]IPAddr{ &quot;loopback&quot;: {127, 0, 0, 1}, &quot;googleDNS&quot;: {8, 8, 8, 8}, } for name, ip := range hosts { fmt.Printf(&quot;%v: %v\\n&quot;, name, ip) } }","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zys980808.github.io/categories/编程语言/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://zys980808.github.io/tags/Go/"},{"name":"编程语言","slug":"编程语言","permalink":"http://zys980808.github.io/tags/编程语言/"}]}]}