<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux目录树标准 - FHS</title>
      <link href="/2020/04/25/Linux/linux-fhs/"/>
      <url>/2020/04/25/Linux/linux-fhs/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux目录树标准-FHS"><a href="#Linux目录树标准-FHS" class="headerlink" title="Linux目录树标准 - FHS"></a>Linux目录树标准 - FHS</h1><p>FHS 全称Filesystem Hierarchy Standard 文件系统层级结构标准。Linux内核在初始化时会生成根目录<code>/</code>为起点的文件目录树，而 FHS 作为Linux的工业标准规范了目录树的基本结构，当然各个发行版在这个基础上还有额外增加的内容。</p><p><a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">FHS官方文档</a></p><p>总分类：</p><ul><li><code>/</code> (root) 与开机系统有关；</li><li><code>/usr</code> (unix software resource) 与软件安装/执行有关；</li><li><code>/var</code> (variable) 与系统运作过程有关</li></ul><p>接下来介绍各个目录具体的作用和意义。</p><h2 id><a href="#" class="headerlink" title="/"></a><code>/</code></h2><p>FHS建议根目录越小越好，且安装内容最好不要与根目录放在同一个分区内，减少根目录的空间占用。原因是根目录最重要，和开机/还原/系统修复等动作密切相关。</p><ul><li>must: <code>/boot</code>, <code>/bin</code>, <code>/dev</code>, <code>/etc</code>, <code>/lib</code>, <code>/media</code>, <code>/mnt</code>, <code>/opt</code>, <code>/run</code>, <code>/sbin</code>, <code>/srv</code>, <code>/tmp</code>, <strong><code>/usr</code>, <code>/var</code></strong></li><li>recommended: <code>/home</code>, <code>/lib&lt;?&gt;</code>, <code>/root</code></li><li>not included: <code>/lost+found</code>, <code>/proc</code>, <code>/sys</code></li></ul><h3 id="boot"><a href="#boot" class="headerlink" title="/boot"></a><code>/boot</code></h3><p>主要存放：</p><ul><li>boot loader<ul><li>grub2则在 <code>/boot/grub2</code> 中</li></ul></li><li>内核相关(vmlinuz, initramfs) (之后开机流程会再碰到)<h3 id="bin"><a href="#bin" class="headerlink" title="/bin"></a><code>/bin</code></h3>放一些特殊的可执行文件 - 在<strong>单人维护模式</strong>下还能够被操作的指令。 </li></ul><p>在/bin底下的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</p><h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a><code>/dev</code></h3><p>存放各种设备(文件形式)</p><p>设备分类：</p><ul><li>字符设备（线性：键盘鼠标）</li><li>块设备（随机：磁盘）</li></ul><p>比要重要的设备：<code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/tty</code> , <code>/dev/loop*</code>, <code>/dev/sd*</code></p><h3 id="etc"><a href="#etc" class="headerlink" title="/etc"></a><code>/etc</code></h3><p>系统最主要的配置文件基本都在这里，不能放二进制文件。通常用户都可<code>read</code>，但一般只有<code>root</code>可以<code>write</code>。</p><h3 id="lib"><a href="#lib" class="headerlink" title="/lib"></a><code>/lib</code></h3><ul><li>开机时会用到的函数库</li><li>为/bin 和 /sin 提供函数库</li><li><code>/lib/modules</code> 存放可更换的驱动程序</li></ul><h3 id="media"><a href="#media" class="headerlink" title="/media"></a><code>/media</code></h3><p>挂载点：便携性设备（光盘软盘）</p><h3 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a><code>/mnt</code></h3><p>临时挂载点</p><blockquote><p>但其实本质来说怎么挂载没有严格限制，哪里都可以挂，预设的文件夹只是作为参考。</p></blockquote><h3 id="opt"><a href="#opt" class="headerlink" title="/opt"></a><code>/opt</code></h3><p>附加的软件包，一般用来装一些第三方软件包，但其实现在很少软件包会往opt放了，主要都放到<code>/usr/local</code></p><h3 id="run"><a href="#run" class="headerlink" title="/run"></a><code>/run</code></h3><p>存放开机后产生的各种数据，包括PID。早期存在 <code>/var/run</code>，现在软连接到<code>/run</code>了。所存数据使用内存，不占用硬盘容量且性能较好。</p><ul><li>锁 <code>/run/lock</code></li></ul><h3 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a><code>/sbin</code></h3><p>系统管理程序，<code>root</code>才能调用的开机、修复、还原指令。</p><h3 id="srv"><a href="#srv" class="headerlink" title="/srv"></a><code>/srv</code></h3><p>网络服务资料存放点，比如<code>/srv/www</code></p><h3 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a><code>/tmp</code></h3><p>临时文件目录，程序两次启动间不能认为这里的数据有保存（断电可能被擦除）</p><h3 id="home"><a href="#home" class="headerlink" title="* /home"></a>* <code>/home</code></h3><p>普通用户的家目录</p><h3 id="lib-lt-gt"><a href="#lib-lt-gt" class="headerlink" title="* /lib&lt;?&gt;"></a>* <code>/lib&lt;?&gt;</code></h3><p>存放其他格式的函数库，通常是 <code>lib64</code>，支持64位的函数</p><h3 id="root"><a href="#root" class="headerlink" title="* /root"></a>* <code>/root</code></h3><p><code>root</code>用户的家目录</p><h3 id="lost-found"><a href="#lost-found" class="headerlink" title="!/lost+found"></a>!<code>/lost+found</code></h3><p>ext2/ext3/ext4才有，/xfs无。文件系统发生错误时会存储一些资料。</p><h3 id="proc"><a href="#proc" class="headerlink" title="!/proc"></a>!<code>/proc</code></h3><p>同样也是个虚拟文件系统（存在内存）。记录内核、进程、各种设备的状态、网络状态等。</p><p>例如 <code>net.ipv4.ip_forward --&gt; /proc/net/ipv4/ip_forward</code></p><p>系统调优的关键入口</p><h3 id="sys"><a href="#sys" class="headerlink" title="!/sys"></a>!<code>/sys</code></h3><p>同样也是个虚拟文件系统（存在内存）。也是记录内核、硬件相关信息。linux 2.6 才出现。</p><p>提供比proc更为理想的访问内存数据的接口。/sys 导出内核数据比 /proc 更合理、设计更好。主要是为管理Linux设备提供统一模型的接口</p><p>同样也是系统调优的关键入口</p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sysfs/" target="_blank" rel="noopener">IBM参考</a></p><h2 id="usr"><a href="#usr" class="headerlink" title="/usr"></a><code>/usr</code></h2><p>放置的资料属于<strong>可分享的</strong>与<strong>不可变动的</strong>(shareable, static)，软件安装相关。</p><p>所有distribution所预置的软件都会放这里，因此有点像Windows的<code>C:\Windows\(当中的一部份) + C:\Program files\</code></p><ul><li>must: <code>./bin</code>, <code>./lib</code>, <code>./local</code>, <code>./sbin</code>, <code>./share</code></li><li>recommended: <code>./games</code>, <code>./include</code>, <code>./libexec</code>, <code>./lib&lt;?&gt;</code>,  <code>./src</code></li></ul><blockquote><p>这个文件夹内容和根目录中重名的即类似的，不再赘述</p></blockquote><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><ul><li><code>/lib</code> –&gt; <code>/usr/lib</code></li><li><code>/lib64</code> –&gt; <code>/usr/lib64</code></li><li><code>/bin</code> –&gt; <code>/usr/bin</code></li><li><code>/sbin</code> –&gt; <code>/usr/sbin</code></li></ul><h3 id="usr-local"><a href="#usr-local" class="headerlink" title="!/usr/local"></a>!<code>/usr/local</code></h3><p>又是一个类似 <code>/usr</code> 的层级目录，但这里放置的是非distribution预置的软件（也就是用户自己下载的）。</p><h3 id="usr-share"><a href="#usr-share" class="headerlink" title="!/usr/share"></a>!<code>/usr/share</code></h3><p>只读的文字资料</p><h3 id="usr-src"><a href="#usr-src" class="headerlink" title="*/usr/src"></a>*<code>/usr/src</code></h3><p>存放源码，比如Linux源码在 <code>/usr/src/linux</code></p><blockquote><p>CentOS8怎么找不到这个文件夹</p></blockquote><h3 id="usr-libexec"><a href="#usr-libexec" class="headerlink" title="*/usr/libexec"></a>*<code>/usr/libexec</code></h3><p>不常用的可执行文件/脚本，比如XWindow, gnome的操作脚本</p><h3 id="usr-include"><a href="#usr-include" class="headerlink" title="*/usr/include"></a>*<code>/usr/include</code></h3><p>一些C/C++头文件，安装某些应用时会用到</p><h2 id="var"><a href="#var" class="headerlink" title="/var"></a><code>/var</code></h2><p>经常变动的文件目录，存放经常被修改的数据文件</p><p>must: <code>./cache</code>, <code>./lib</code>, <code>./lock</code>, <code>./log</code>, <code>./mail</code>, <code>./run</code>, <code>./spool</code></p><h3 id="var-cache"><a href="#var-cache" class="headerlink" title="/var/cache"></a><code>/var/cache</code></h3><p>应用程序运行过程中的缓存数据</p><h3 id="var-lib"><a href="#var-lib" class="headerlink" title="/var/lib"></a><code>/var/lib</code></h3><p>各个程序运行过程中需要时用到的数据。在此目录下各自软件应该要有独立的目录。举例来说，MySQL的数据放置到<code>/var/lib/mysql/</code></p><h3 id="var-lock"><a href="#var-lock" class="headerlink" title="/var/lock"></a><code>/var/lock</code></h3><p>设备锁，已软链接到 <code>/run/lock</code></p><h3 id="var-log"><a href="#var-log" class="headerlink" title="/var/log"></a><code>/var/log</code></h3><p>重要的日志文件目录</p><h3 id="var-mail"><a href="#var-mail" class="headerlink" title="/var/mail"></a><code>/var/mail</code></h3><p>邮件，软链接到 <code>/var/spool/mail</code></p><h3 id="var-run"><a href="#var-run" class="headerlink" title="/var/run"></a><code>/var/run</code></h3><p>运行中程序的PID，软链接到 <code>/run</code></p><h3 id="var-spool"><a href="#var-spool" class="headerlink" title="/var/spool"></a><code>/var/spool</code></h3><p>储存等待被使用的<strong>队列</strong>数据，这些数据被使用完以后通常会被删除掉。比如mail和crontab</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux快速入门</title>
      <link href="/2020/04/19/Linux/Linux-Quick-Start-md/"/>
      <url>/2020/04/19/Linux/Linux-Quick-Start-md/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux快速入门"><a href="#Linux快速入门" class="headerlink" title="Linux快速入门"></a>Linux快速入门</h1><p>个人食用的Linux快速入门小手册。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://www.linuxcool.com/" target="_blank" rel="noopener">Linux命令大全(手册)</a></li></ul><a id="more"></a><h2 id="Shell终端"><a href="#Shell终端" class="headerlink" title="Shell终端"></a>Shell终端</h2><p>Linux系统的内核负责完成对硬件资源的分配、调度等管理任务。Shell将用户的基于计算机的命令转述给内核执行。</p><ul><li>6个预设终端，使用快捷键<code>[Ctrl] + [Alt] + [F1]~[F6]</code>切换</li><li>↑ ↓ 历史指令</li><li>Tab补全</li><li>批处理脚本</li><li>环境变量</li><li>重定向</li><li>…</li></ul><blockquote><p>关于更多的内容会在后面的Bash特性讲到，这里简单带过</p></blockquote><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><ul><li>在只记得部分命令关键字的场合，我们可通过<code>man -k</code>来搜索；</li><li>需要知道某个命令的简要说明，可以使用 <code>whatis</code>；而更详细的介绍，则可用info命令；</li><li>查看命令在哪个位置，我们需要使用<code>which</code>；</li><li>而对于命令的具体参数及使用方法，我们需要用到强大的<code>man</code>；</li></ul><blockquote><p>看用法，用<code>man</code>；更细致的说明和介绍要用<code>info</code></p></blockquote><h3 id="man"><a href="#man" class="headerlink" title="man"></a><code>man</code></h3><p>使用<code>man</code>查看手册是非常重要的学习技能，</p><ul><li><code>man # keyword</code> 可以指定对应的手册序号</li><li><code>man -f keyword</code> 浏览不同手册下的该条目信息</li><li><code>man -k keyword</code> 进行内容检索</li></ul><table><thead><tr><th>序号</th><th>代表内容</th></tr></thead><tbody><tr><td><strong>1</strong></td><td><strong>使用者在shell环境中可以执行的指令或可执行程序；比如<code>ls</code></strong></td></tr><tr><td>2</td><td>系统核心可调用的函数与工具等</td></tr><tr><td>3</td><td>一些常用的函数(function)与函数库(library)，大部分为C的函数库(<code>libc</code>)；比如<code>printf</code>函数</td></tr><tr><td>4</td><td>设备的说明，通常在/dev下的档案</td></tr><tr><td><strong>5</strong></td><td><strong>配置文件的格式；比如<code>/etc/passwd</code></strong></td></tr><tr><td>6</td><td>游戏(games)</td></tr><tr><td>7</td><td>惯例与协定等，例如Linux文件系统、网络协议、ASCII code等等的说明</td></tr><tr><td><strong>8</strong></td><td><strong>系统管理员可用的管理指令</strong></td></tr><tr><td>9</td><td>跟kernel有关的文件</td></tr></tbody></table><p>比如<code>man fork</code>会显示fork(2)；在前期的学习 1, 5, 8 相对重要一些；到后面学APUE估计就经常要查 2, 3, 9 了</p><p>查阅文档时可以进行的一些操作：</p><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空白键</td><td>向下翻一页</td><td></td></tr><tr><td>[Page Down]</td><td>向下翻一页</td><td></td></tr><tr><td>[Page Up]</td><td>向上翻一页</td><td></td></tr><tr><td>[Home]</td><td>去到第一页</td><td></td></tr><tr><td>[End]</td><td>去到最后一页</td><td></td></tr><tr><td>/string</td><td>向『下』搜寻string 这个字串</td><td></td></tr><tr><td>?string</td><td>向『上』搜寻string 这个字串</td><td></td></tr><tr><td>n, N</td><td>利用/ 或? 来搜寻字串时，可以用n 来继续下一个搜寻(不论是/ 或?) ，可以利用N 来进行『反向』搜寻</td><td></td></tr><tr><td>q</td><td>结束这次的man page</td><td></td></tr></tbody></table><h3 id="info"><a href="#info" class="headerlink" title="info"></a><code>info</code></h3><p>基本上，info与man的用途其实差不多，但info内容拆分成可跳转的节点，形成树状的结构。</p><ul><li><code>U</code> 返回上层父节点（目录）</li><li><code>N</code> 下一个节点</li><li><code>P</code> 上一个节点</li><li><code>Enter</code> 进入超链接</li><li><code>h</code> 求助</li></ul><h2 id="目录命令"><a href="#目录命令" class="headerlink" title="目录命令"></a>目录命令</h2><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a><code>cd</code></h3><p>切换目录</p><ul><li><code>cd -</code> = <code>cd ${OLDPWD}</code> 访问上一次所在目录</li></ul><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a><code>pwd</code></h3><p>查看当前目录</p><ul><li>即 <code>echo ${PWD}</code></li></ul><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a><code>ls</code></h3><p>展示文件夹文件</p><ul><li><code>-R</code> 递归显示</li><li><code>-d</code> 仅查看目录自身（管道下好用）</li><li><code>-l</code> 长列表，详细信息</li><li><code>-h</code> 文件大小加单位</li></ul><h2 id="命令相关"><a href="#命令相关" class="headerlink" title="命令相关"></a>命令相关</h2><h3 id="which"><a href="#which" class="headerlink" title="which"></a><code>which</code></h3><p>定位指令/别名的位置</p><ul><li><code>--skip-alias</code> 可以跳过别名(??)</li></ul><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a><code>whereis</code></h3><p>定位一个命令的 bin, src, man</p><ul><li><code>-b</code> 只看binary</li><li><code>-m</code> 只看manual</li><li><code>-s</code> 只看src</li></ul><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a><code>alias</code></h3><p>查看别名列表</p><ul><li>定义别名，<code>alias NAME=VALUE</code>，只对当前shell进程有效</li><li><code>unalias</code> 撤销别名</li></ul><h3 id="history"><a href="#history" class="headerlink" title="history"></a><code>history</code></h3><p>查看历史命令</p><ul><li>登出也会保存到文件中</li><li>可以通过设置环境变量定制history<ul><li><code>$HISTSIZE</code> 命令历史条数</li><li><code>$HISTFILE</code>: 持久保存命令历史的文件位置</li><li><code>$HISTFILESIZE</code>: 上述文件大小</li><li><code>$HISTCONTROL</code>: 控制命令历史的记录方式 <ul><li><code>ignoredups</code>: 忽略重复的命令</li><li><code>ignorespace</code>: 忽略空白字符开头的命令</li><li><code>ignoreboth</code>: 两者同时生效</li></ul></li></ul></li><li><code>!#</code>: 再一次执行 history 中的命令 </li><li><code>!STRING</code>: 执行最近的以<code>STRING</code>开头的命令</li><li><code>ESC + &#39;.&#39;</code> 或 <code>ALT+ &#39;.&#39;</code>: 上一条命令的最后一个参数，等同于 <code>!$</code></li></ul><h2 id="时间命令"><a href="#时间命令" class="headerlink" title="时间命令"></a>时间命令</h2><h3 id="date"><a href="#date" class="headerlink" title="date"></a><code>date</code></h3><p>显示或设置<strong>系统时钟</strong>；系统时钟是开机获取完硬件时间后由CPU自己跳的时间</p><ul><li>自定义显示格式: <code>date +&quot;%Y-%m-%d-%H-%M-%S&quot;</code>(更多的格式可以自行查帮助); </li><li><code>%j</code> 可看是一年中的第几天</li><li>设定日期时间: <code>date [MMDDhhmm[[CC]YY][.ss]]</code></li><li>另一个设置日期时间的方法: <code>date -s &quot;20170901 8:30:00&quot;</code></li></ul><h3 id="hwclock"><a href="#hwclock" class="headerlink" title="hwclock"></a><code>hwclock</code></h3><p>显示或设定<strong>硬件时钟</strong>；硬件时钟是BIOS供电维护的时间</p><ul><li><code>-s --hctosys</code>: 硬件时间写入到系统时间</li><li><code>-w --systohc</code>: 系统时间写入到硬件时间</li></ul><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a><code>cal</code></h3><p>日历 <code>cal [[month] year]</code></p><h2 id="其他常用指令"><a href="#其他常用指令" class="headerlink" title="其他常用指令"></a>其他常用指令</h2><h3 id="file"><a href="#file" class="headerlink" title="file"></a><code>file</code></h3><p>查看文件类型</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a><code>type</code></h3><p>查看命令类型，内置or外部可执行文件</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a><code>cat</code></h3><p>输出文本文件内容</p><ul><li><code>-n</code> 加行数</li></ul><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a><code>echo</code></h3><p>输出指定字符串</p><ul><li><code>-e</code> 使转义符生效 (需要引号)</li><li>“” 弱引用，替换 <code>$</code> 变量; 例如<code>echo &quot;${PWD}&quot;</code></li><li>‘’ 强引用，不替换 <code>$</code> 变量</li></ul><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a><code>shutdown</code></h3><p>关机 <code>shutdown [OPTIONS…] [hh:mm/+m] [wall msg]</code></p><ul><li><code>shutdown now</code> = <code>shutdown +0</code></li><li><code>-r</code> = <code>reboot</code></li><li><code>-p</code> = <code>poweroff</code></li><li><code>-h</code> = <code>halt</code></li><li><code>-c</code> 取消</li></ul><h3 id="wall"><a href="#wall" class="headerlink" title="wall"></a><code>wall</code></h3><p>向所有用户发出信息</p><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a><code>sync</code></h3><p>将内存中暂存的信息写入硬盘，</p><ul><li>good practice: 定时和关机前<code>sync</code>一下</li></ul><h3 id="who"><a href="#who" class="headerlink" title="who"></a><code>who</code></h3><p>查看当前登录用户的信息</p><ul><li><code>-r</code> 运行级别？</li><li><code>w</code> 强化版 <code>who</code>，还显示运行状况</li></ul><h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a><code>bc</code></h3><p>计算器、单位换算器(?)</p><ul><li><code>+,-,*,/,^,%</code></li><li><code>scale = #</code> 设置显示小数点，默认为0位</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有向图边的类型</title>
      <link href="/2018/11/26/Algorithm/graph-edge-type/"/>
      <url>/2018/11/26/Algorithm/graph-edge-type/</url>
      
        <content type="html"><![CDATA[<h1 id="有向图边的类型"><a href="#有向图边的类型" class="headerlink" title="有向图边的类型"></a>有向图边的类型</h1><p>有向图边有如下几个类型：</p><ul><li>tree edge 树边</li><li>foward edge 前向边</li><li>back edge 回边</li><li>cross edge 横跨边</li></ul><p>一张图即可解释：</p><p><img src="1.png" alt></p><a id="more"></a><h1 id="判断有向图边的类型"><a href="#判断有向图边的类型" class="headerlink" title="判断有向图边的类型"></a>判断有向图边的类型</h1><p>在DFS的过程中，可以直接用pre, post 值来判断；当然首先得知道如何计算 pre, post 值，这同样可以用一张图来解释（该图数对为 pre,post）：</p><p><img src="2.png" alt></p><ul><li>如果一个点pre和post值不存在，说明该点未被访问过，是一个 <strong>树边</strong> （例如图中<code>F-&gt;G</code>)</li><li>如果 <code>pre(u) &lt; pre(v) &lt; post(v) &lt; post(u)</code>，说明 u 肯定 v 的祖先<ul><li>若有 v-&gt;u， 则该边是一个 <strong>回边</strong>；（例如图中<code>F-&gt;B</code>)</li><li>若有 u-&gt;v, 且显然此时pre(v)和post(v)都存在，不可能是树边，则该边是 <strong>前向边</strong> （例如图中<code>E-&gt;G</code>)</li></ul></li><li>对于 <strong>横跨边</strong>，已经是分属两条不同的深搜路径，所以必然的，两个点的(pre,post)区间没有重叠（例如图中 <code>D-&gt;H</code></li></ul><p>可以总结为下图：</p><p><img src="3.png" alt></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="判断有向图是否有圈"><a href="#判断有向图是否有圈" class="headerlink" title="判断有向图是否有圈"></a>判断有向图是否有圈</h2><p>等价于判断图中是否有 <strong>回边</strong></p><h2 id="进行拓扑排序"><a href="#进行拓扑排序" class="headerlink" title="进行拓扑排序"></a>进行拓扑排序</h2><p>首先要知道什么是拓扑排序：拓扑排序就是将结点依次排序，使得图内的边都是从该序列前面的点流向后面的点（显然前提是这个图不能有环）</p><p>例：穿衣服问题，见下图。</p><p><img src="4.png" alt></p><p><strong>正如图中所示，只要按Post值倒序就可以了</strong></p><blockquote><p>当然这题还有另外的解法：不断从图中删去in-degree为0的点（source）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强连通分量</title>
      <link href="/2018/11/26/Algorithm/graph-scc/"/>
      <url>/2018/11/26/Algorithm/graph-scc/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Definition: A strongly connected component (SCC) of a directed graph G = (V, E) is a maximal set of vertices C ⊆ V such that every pair of vertices u and v in C are reachable from each other.</p><p>翻译过来就是，把一个有向图划分成<strong>尽可能大</strong>的几个集合，集合内的结点两两互相都可达，这样的每一个“集合”就是一个<strong>强连通分量</strong></p><a id="more"></a><h2 id="求解过程分析"><a href="#求解过程分析" class="headerlink" title="求解过程分析"></a>求解过程分析</h2><blockquote><p>求解一个有向图的强连通分量的算法不是一蹴而就的，下面就叙述一下这个算法逐步形成的过程</p></blockquote><ul><li>将强连通分量都“缩圈”缩成一个点，得到的图是<strong>DAG</strong>（有向无环图） —— 任何一个有向图都是其 强连通分量 组成的DAG</li></ul><p><img src="5.png" alt></p><ul><li><p>一个DAG，一定会有Sink（入度为0的点）和Source（出度为0的点）</p></li><li><p>如果能从Sink联通量里面任意一个点开始DFS，就可以求出这个Sink联通量，因为它<strong>跑不出去</strong>。</p></li><li><p>然后删去这个联通量，DFS树仍有叶子——就是仍有Sink，<strong>重复上述操作</strong></p></li></ul><p>可是问题就在于：并无法找到Sink联通量里的一个点。那该怎么办呢？</p><ul><li>虽然没法找到Sink联通量，但我们可以找得到<strong>Source</strong>：在完整DFS过程以后，Post值最大的就一定在Source联通量内：<ul><li>假设从Source内的点开始DFS，显然Post最大的就在Source内（Root）</li><li>假设不从Source内的点开始DFS，Source是到不了的；后面必然又要从Source内的点再次DFS，导致Post值最大</li></ul></li></ul><p>但找到Source也没有用啊，从Source内的一点开始DFS，肯定会<strong>跑出去</strong>，那有什么用呢？</p><ul><li><strong>把边反向，Source就变成了Sink</strong>，而且联通的性质是不变的——强联通量还是那些强联通量</li></ul><p><img src="6.png" alt></p><ul><li>这样就可以从Post最大的值开始DFS，找出第一个强联通量，并且从图中删去</li><li>更棒的是，删去第一个强联通量以后，<strong>现在Post最大的就是删后图的Sink值</strong>，这样就可以不断重复前面的步骤</li></ul><h2 id="求解步骤总结"><a href="#求解步骤总结" class="headerlink" title="求解步骤总结"></a>求解步骤总结</h2><blockquote><p>如果完整地看完了上面，下面的求解步骤可以直接忽略的啦</p></blockquote><ol><li>进行DFS，求出每个结点的Post值，存入优先队列</li><li>将有向图边反向 $G {\rightarrow} G^T$</li><li>从Post值最高的点开始DFS，并将DFS所得的点存入一个集合，形成一个强连通分量；同时将这些点从图中删去</li><li>重复第三步，直到所有联通量都形成</li></ol><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>第一次DFS求Post值并放入优先队列：<br><br>$O(V+E) + O(log_2V) = O(V+E)$</li><li>将有向图边反向：<br><br>$O(V+E)$</li><li>求强联通量的过程，实际上加起来就是一次完整的DFS而已：<br><br>$O(V+E)$</li></ul><h3 id="总复杂度"><a href="#总复杂度" class="headerlink" title="总复杂度"></a>总复杂度</h3><p>$O(V+E)$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经历-字节跳动后台开发(基础架构)实习岗</title>
      <link href="/2018/11/26/Interview-ByteDance/"/>
      <url>/2018/11/26/Interview-ByteDance/</url>
      
        <content type="html"><![CDATA[<p>昨天下午尝试了第一次视频面试，面试的岗位是字节跳动的[后台开发-基础架构]实习岗，由于我本身的技术的确是远远没有达到岗位的要求，所以这一次的面试也只是抱着试一试的态度，了解一下面试的流程，积累一些经验，同时通过面试进一步了解自己应该努力的方向。</p><a id="more"></a><p>时间定在了周日下午的四点，直到面试前都没有加上HR的微信，所以在面试前心中还是有种“我要被鸽了”的感觉。点开通知邮件发给我的面试链接以后，点开展示的就是牛客网的面试系统界面:</p><p><img src="interface.png" alt></p><p>四点过了两分钟，面试官就上线了，是个很有亲和力的中年男子。此时我还是很紧张的，毕竟是第一次参加正经的面试，所以谈吐都有些不自然了。调整视频连接耽误了一小段时间。</p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>面试官看了看我的简历，上面有一项是“熟悉Go语言编程”；我听到他提起这个心里就凉了一半：其实自己对于Go语言也借由本学期的服务计算课进行了个入门而已，远算不上熟悉。然后他说有一道题特别适合用Go来编程，就出给我做了:</p><hr><p>先定义了一个<code>read</code>函数，这个函数就是一个Socket接口，每次会读数据入缓冲区；然后要我写一个<code>readLine</code>函数，按行输出Socket读的数据，他一开始先给了我两个提示：</p><ul><li><code>read</code>是会阻塞的</li><li>每次<code>read</code>得到的数据有可能有换行符<code>\n</code>，有可能没有，也有可能会有多个</li></ul><p>这是面试官给出的函数定义:</p><pre><code class="go">// read: socket api // - fd: socket 的文件fd// - buf: 读入缓冲区// - N: 最大数据大小func read(fd int,  buf []byte, N int) int {}</code></pre><hr><p>听完题后我整个人就很慌了，因为心里总有股声音觉得自己不会。而实际上我也的确对Go不熟悉，很多类似<code>append</code>, <code>channel</code> 这样的操作还需要查自己或别人的博客去写。</p><p>虽然慌的一匹，但总归还是有一点思路（现在想来这也不过就是一道生产者、消费者的问题），中间面试官提示我用<code>channel</code>去做这一道题，但我并没有用过所以短暂思考后也放弃了这个思路。</p><p>最后用一个循环调用<code>read</code>的方法完成了这道题，用<code>last</code>变量来存储上一次调用<code>read</code>所剩下的内容：</p><pre><code class="Go">type Read struct {    fd int          // socket fd    N  int          // max size per line    last []byte     // last read remained}func (r Read) readLine() string {    var buf []byte    for read(r.fd, buf, r.N) != 0 {        for i := 0; i &lt; buf.size(); i++ {            if buf[i] == &#39;\n&#39; {                temp := append(last, buf[:i]...)                r.last = buf[i+1:]                return temp            }        }    }    return &quot;&quot;}</code></pre><p>这中间有几个严重的逻辑错误，都是面试官提出来然后我才能反应过来并迅速修正：</p><ul><li><p>如果某次<code>read</code>得到了多行，那么<code>last</code>存储的数据就会是多行的，代码没有考虑这个问题。解决方案我也立马能想出来：在执行循环调用<code>read</code>之前先检查<code>last</code>是否为空，不为空就遍历一遍看看是否有一行存在，有则返回第一行并对<code>last</code>进行切割</p></li><li><p>如果某次<code>read</code>没有换行，这份代码并没有将这次读取的数据保存。显然解决方案就是在每次循环的末尾增加一个<code>append(last, buf...)</code></p></li></ul><p>这也体现出我的思维是很不严谨的，然后代码能力也偏弱。我在以往做算法题的时候就很依赖提交，通过提交去检查自己的代码有没有问题，这样在考试的时候就会体现出我这样效率其实很低，而且长期的依赖也导致了自己基本的Debug能力有所降低。</p><p>在编程测试结束的时候，面试官告诉我简历不能给面试带来信息不对称，比如刚入门Go语言就不应该写成熟悉；也真是令人汗颜。自己的简历的确有着不少的水分，需要重新修改一番。</p><h2 id="后阶段面试"><a href="#后阶段面试" class="headerlink" title="后阶段面试"></a>后阶段面试</h2><p>后阶段面试就更加能显现我简历的水分了，面试官看到我在简历里写了我在做MIT的6.828的实验，他想要从这里展开。到这里我就不得不和盘托出其实我只做了这个系列实验的Lab1，然后考虑到学这个又要去学x86编程，耗费时间有点多然后就搁置了。听到这里其实面试官已经基本宣告面试fail了。他告诉我这个部门是负责存储的，所以对算法或者某一后台领域的知识会要求很高，所以希望我可以明确一个方向，回去好好修炼再去考虑面试的事情。他还推荐我可以去看CMU的存储课程。另外，他还说我可以考虑面试一下后台业务开发的岗位，链接在面试通知邮件里也可以找到。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次面试也就这样在不安中结束了。的确这次就是抱着来试试的态度进行面试，所以结果不如意倒也正常。面试时间虽然只有短短的一个多小时，但也还是了解到了自己很多的缺陷：代码能力亟待提高，需要专精一个后台的方向（目前我想做的是网络编程），另外基础课程的知识也非常重要，如果有时间得捡回6.828，再加一些存储的课程。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox安装 WinXP+CentOS双系统</title>
      <link href="/2018/11/24/Linux/VitualBox-Double-System/"/>
      <url>/2018/11/24/Linux/VitualBox-Double-System/</url>
      
        <content type="html"><![CDATA[<p>建议在开始之前，先在<a href="http://linux.vbird.org/linux_basic/0130designlinux.php" target="_blank" rel="noopener">这里</a>学习分区和开机的知识，然后按照<a href="http://linux.vbird.org/linux_basic/0157installcentos7.php" target="_blank" rel="noopener">这个</a>步骤把CentOS单系统安装成功之后，再来看这里。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://linux.vbird.org/linux_basic/0157installcentos7.php#multiboot" target="_blank" rel="noopener">鸟哥Linux私房菜 - 多重开机安装流程与管理</a></li><li><a href="http://www.jinbuguo.com/linux/grub.cfg.html" target="_blank" rel="noopener">Grub2配置文件详解</a></li></ul><a id="more"></a><h1 id="Let’s-Go"><a href="#Let’s-Go" class="headerlink" title="Let’s Go"></a>Let’s Go</h1><p>采用的是先装 CentOS, 再安装Windows的过程，体验一下 “救援” 被Windows覆盖的MBR的过程</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>XP ISO 安装版，有些版本是所谓 装机版 是不能在Virtual Box跑的，它需要在Windows下打开来运行；我们需要的是ISO映像 <a href="http://www.2013xp.com/xp/3057.html" target="_blank" rel="noopener">这个</a>就可以</p><p>CentOS-7 minimal, 官网下载即可</p><h2 id="新建虚拟硬盘"><a href="#新建虚拟硬盘" class="headerlink" title="新建虚拟硬盘"></a>新建虚拟硬盘</h2><blockquote><p>这一步很关键</p></blockquote><p>由于XP系统只能识别IDE硬盘，因此在新建系统时如果选择Ubuntu，Win10之类的都会自动分配一个SATA硬盘，这会导致WindowsXP无法识别，从而安装失败。</p><p>选择Linux-&gt;其他Linux系统则会分配IDE接口的硬盘。另外，直接选择XP系统会导致CentOS中途无法安装，原因暂时不明</p><blockquote><p>还需继续研究</p></blockquote><h2 id="使用CentOS分区并安装CentOS"><a href="#使用CentOS分区并安装CentOS" class="headerlink" title="使用CentOS分区并安装CentOS"></a>使用CentOS分区并安装CentOS</h2><p>当然WindowsXP也能进行分区，只不过界面和功能来说还是CentOS更胜一筹；详细的步骤跟着 <a href="http://linux.vbird.org/linux_basic/0157installcentos7.php#multiboot_design" target="_blank" rel="noopener">鸟哥的教程</a>就行了。当然博主的分区规划和鸟哥的略有不同，如下所示：</p><ul><li>1M ~ 15G : 主要分区1，用于安装CentOS (<code>sda1</code>)</li><li>15G ~ 30G : 主要分区2，用于安装WindowsXP (<code>sda2</code>)</li><li>30G ~ 40G : 扩展分区 (<code>sda3</code>)<ul><li>30G ~ 38G ：逻辑分区1，用于windows和cent共享数据 (<code>sda5</code>) <blockquote><p>注意到这里从5开始，因为如前所述1~4分给了primary和extended</p></blockquote></li><li>38G ~ 40G : 逻辑分区2，用于换页，增强内存功能 (<code>sda6</code>)</li></ul></li></ul><h2 id="安装WindowsXP"><a href="#安装WindowsXP" class="headerlink" title="安装WindowsXP"></a>安装WindowsXP</h2><p>重新设置一下启动的ISO镜像，选择WindowsXP镜像启动，然后安装，注意别安装错了（当然如果不小心点了CentOS的系统盘会有提示上面装了系统）</p><p>安装完以后，虚拟硬盘的MBR就被WindowsXP的boot loader “霸道”地覆盖了，重启就只能进入WindowsXP系统</p><h2 id="救援MBR内的Boot-Loader"><a href="#救援MBR内的Boot-Loader" class="headerlink" title="救援MBR内的Boot Loader"></a>救援MBR内的Boot Loader</h2><p>此时我们需要替换MBR的boot loader，不能再让XP占用下去了！网上很多建议装双系统是先装Windows再装Linux，是因为很多Linux版本自带了一个强大的 boot loader - grub2, 它可以实现多重引导（其实本质上就是引导到某个分区的booting section上而已）</p><p>现在在MBR被覆盖的情况下，我们仍然能通过CentOS的安装程序进行“救援”：关机，切换CentOS的ISO镜像，然后按照<a href="http://linux.vbird.org/linux_basic/0157installcentos7.php#multiboot_rescue" target="_blank" rel="noopener">鸟哥的教程</a>进行救援</p><h2 id="Grub2设置"><a href="#Grub2设置" class="headerlink" title="Grub2设置"></a>Grub2设置</h2><p>鸟哥的教程里有一部分对Grub2的设置，乍一看还是蛮困扰的，幸亏看了这一片<a href="http://www.jinbuguo.com/linux/grub.cfg.html" target="_blank" rel="noopener">教程</a>，我知道了<code>set root=&#39;(hd0,3)&#39;</code>指的是第一块硬盘内的第三个主要分区；而博主的分区规划是把Windows安装在第二个主要分区，因此改成<code>set root=&#39;(hd0,2)</code>即可，<strong>注意这里格式严格不能有多余空格哦！</strong></p><h2 id="成功！"><a href="#成功！" class="headerlink" title="成功！"></a>成功！</h2><p>然后重启，就会发现 Grub2 多了一个WindowsXP，截图留念：</p><p><img src="dsys_grub2.jpg" alt></p><p>当然Windows也启动成功了：</p><p><img src="dsys_xp.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go基础语法</title>
      <link href="/2018/11/24/Go-Learning/"/>
      <url>/2018/11/24/Go-Learning/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#helloworld">HelloWorld</a></li><li><a href="#%e5%9f%ba%e7%a1%80">基础</a><ul><li><a href="#%e5%8c%85">包</a></li><li><a href="#%e5%87%bd%e6%95%b0">函数</a></li><li><a href="#%e5%8f%98%e9%87%8f">变量</a></li><li><a href="#%e6%8e%a7%e5%88%b6%e8%af%ad%e5%8f%a5">控制语句</a></li><li><a href="#%e6%8c%87%e9%92%88">指针</a></li><li><a href="#%e7%bb%93%e6%9e%84%e4%bd%93">结构体</a></li><li><a href="#%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87">数组和切片</a></li><li><a href="#%e6%98%a0%e5%b0%84">映射</a></li><li><a href="#%e5%87%bd%e6%95%b0%e5%80%bc">函数值</a></li><li><a href="#%e5%87%bd%e6%95%b0%e9%97%ad%e5%8c%85">函数闭包</a></li></ul></li><li><a href="#%e6%96%b9%e6%b3%95%e5%92%8c%e6%8e%a5%e5%8f%a3">方法和接口</a><ul><li><a href="#%e6%96%b9%e6%b3%95">方法</a></li><li><a href="#%e6%8e%a5%e5%8f%a3">接口</a></li></ul></li></ul><h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><pre><code class="Go">package main/*Every Go program is made up of packages.Programs start running in package main.*/import &quot;fmt&quot;func main() {    fmt.Println(&quot;Hello, 世界&quot;)}</code></pre><a id="more"></a><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>按照约定，包名与导入路径的最后一个元素一致。例如：”math/rand”下的包源码均以 <code>package rand</code> 语句开始</p><ul><li>导入一个包</li></ul><pre><code class="Go">import &quot;fmt&quot;</code></pre><ul><li>导入多个包</li></ul><pre><code class="Go">import (    &quot;fmt&quot;    &quot;math/rand&quot;)import &quot;fmt&quot;import &quot;math&quot;</code></pre><p>包中大写为“导出”</p><pre><code class="Go">fmt.Println(math.pi) //报错fmt.Println(math.Pi) //正确</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>简单的例子：</p><pre><code class="Go">package mainimport &quot;fmt&quot;/*- variable type: after name- return value type : after parameters*/func add(x int, y int) int {    return x + y}func main() {    fmt.Println(add(42, 13))}</code></pre><p>相同类型形参可省略一个,例如上面</p><pre><code class="Go">x int, y int</code></pre><p>可写作</p><pre><code class="Go">x, y int</code></pre><p>返回值可为多个</p><pre><code class="Go">func swap(x, y string) (string, string) {    return y, x}func main() {    a, b := swap(&quot;hello&quot;, &quot;world&quot;)  //简洁赋值，等价于var a, b string = swap(...)    fmt.Println(a, b)}</code></pre><p>命名返回值，直接返回这些命名；长函数会影响可读性</p><pre><code class="Go">func split(sum int) (x, y int) {    x = sum * 4 / 9    y = sum - x    return}</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>又是一个例子</p><pre><code class="Go">package mainimport &quot;fmt&quot;var c, python, java boolfunc main() {    var i int    fmt.Println(i, c, python, java)}/* 输出结果：0 false false false看来是有默认初始化的过程*/</code></pre><p>基本类型</p><pre><code class="Go">bool    //1 bytestring int  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptr/*其中，int, uint 和 uintptr（尚未知道用处）在32位系统上为32位(4bytes)宽，64-&gt;64。需要整数时尽量使用int*/byte // alias for uint8rune // alias for int32     // represents a Unicode code pointfloat32 float64//注意这里没有单纯的float了complex64 complex128</code></pre><p>多个变量同时赋值</p><pre><code class="Go">var i, j int = 1, 2var c, python, java = true, false, &quot;no!&quot; //省略类型，自动从值获取</code></pre><p>简洁赋值语句；不能在函数外使用（函数外每个语句必须以关键字开始，如var, func）</p><pre><code class="Go">k := 3//等价于var k = 3</code></pre><p>语法块变量声明</p><pre><code class="Go">var (    ToBe   bool       = true    MaxInt uint64     = 1&lt;&lt;64 - 1    z      complex128 = cmplx.Sqrt(-5 + 12i))</code></pre><p>默认初始化值</p><pre><code class="Go">func main() {    var i int    var f float64    var b bool    var s string    fmt.Printf(&quot;%v %v %v %q\n&quot;, i, f, b, s)}/* 输出结果0 0 false &quot;&quot;*/</code></pre><p>类型转换：和C++类似，但不存在隐式转换</p><pre><code class="Go">i := 42PPf := float64(i)u := uint(f)//下面会报错i := 42var f float64 = i</code></pre><p>常量const关键字，不能用:=赋值</p><pre><code class="Go">const World = &quot;世界&quot;</code></pre><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>Go中循环结构只有 for; for无小括号，但一定要有大括号</p><pre><code class="Go">sum := 0for i := 0; i &lt; 10; i++ {    sum += i}fmt.Println(sum)</code></pre><p>for内三个语句都是optional（可作while语句）</p><pre><code class="Go">for ;sum&lt;1000;{}for sum&lt;1000 {} //分号再去掉，形如whilefor {}  //无限循环</code></pre><p>条件语句，也是无需小括号，必须大括号</p><pre><code class="Go">if x &lt; 0 {}</code></pre><p>if条件判断前可执行一个简单语句, 该语句声明的变量仅在if内</p><pre><code class="Go">if v := math.Pow(x, n); v &lt; lim {    return v}</code></pre><p>练习 - 利用牛顿法实现平方根函数</p><pre><code class="Go">package mainimport (    &quot;fmt&quot;    &quot;math&quot;)func Sqrt(x float64) float64{    z := 1.0    for math.Abs(z*z - x) &gt; 1e-15{        z -= (z*z - x) / (2*z)    }    return z}func main(){    fmt.Println(Sqrt(2))    fmt.Println(math.Sqrt(2))}</code></pre><p>switch 语句</p><ul><li>不需要break，只会运行选中的case</li><li>可通过在结尾加 fallthrough 语句延续分支</li><li>case无需为常量，取值不必为整数</li></ul><pre><code class="Go">fmt.Print(&quot;Go runs on &quot;)switch os := runtime.GOOS; os {case &quot;darwin&quot;:    fmt.Println(&quot;OS X.&quot;)case &quot;linux&quot;:    fmt.Println(&quot;Linux.&quot;)default:    // freebsd, openbsd,    // plan9, windows...    fmt.Printf(&quot;%s.&quot;, os)}</code></pre><p>switch 可以不带条件（等价于switch(true))，可当做if then else结构，更加清晰</p><pre><code class="Go">t := time.Now()switch {case t.Hour() &lt; 12:    fmt.Println(&quot;Good morning!&quot;)case t.Hour() &lt; 17:    fmt.Println(&quot;Good afternoon.&quot;)default:    fmt.Println(&quot;Good evening.&quot;)}</code></pre><p>defer，在外层函数返回后执行，其实参会立即求值（压入栈中）</p><pre><code class="Go">func main() {    fmt.Println(&quot;counting&quot;)    for i := 0; i &lt; 10; i++ {        defer fmt.Println(i)    }    fmt.Println(&quot;done&quot;)}/* 输出结果：    counting    done    9    8    ...    0*/</code></pre><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针零值为<code>nil</code>,声明如下：</p><pre><code class="Go">var p *int</code></pre><p>&amp; * 操作和 C比较类似，但没有指针运算</p><pre><code class="Go">//&amp;操作i := 42var p *int = &amp;i//*操作fmt.Println(*p)*p = 21</code></pre><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>简单例子</p><pre><code class="Go">type Vertex struct {    X int    Y int}func main() {    fmt.Println(Vertex{1, 2})    //注意其赋值使用大括号}</code></pre><p>通过名字赋值</p><pre><code class="Go">v1 = Vertex{1, 2}v2 = Vertex{X: 1}   //v2.Y = 0</code></pre><p>点号访问成员</p><pre><code class="Go">v := Vertex{1, 2}v.X = 4fmt.Println(v.X)</code></pre><p>指针访问结构体，<code>(*p).X</code> 等价于 <code>p.X</code></p><pre><code class="Go">v := Vertex{1, 2}p := &amp;v(*p).X = 1e9p.X = 1e9fmt.Println(v)</code></pre><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><p>数组例子，大小需为常数</p><pre><code class="Go">func main() {    var a [2]string    a[0] = &quot;Hello&quot;    a[1] = &quot;World&quot;    fmt.Println(a[0], a[1])    fmt.Println(a)    primes := [6]int{2, 3, 5, 7, 11, 13}    fmt.Println(primes)}</code></pre><p>切片很常用</p><ul><li>左闭右开</li><li>就像数组的局部引用，本身不存数据</li><li><p>上下界可忽略（下界默认0，上界默认数组/切片长度）</p><pre><code class="Go">func main() {  primes := [6]int{2, 3, 5, 7, 11, 13}  var s []int = primes[1:4]  fmt.Println(s)}/* 输出结果  [3, 5, 7]*/</code></pre></li></ul><p>值得注意的是，这是一个数组：</p><pre><code class="Go">[3]bool{true, true, false}</code></pre><p>而这创建了同样的数组，再构建了它的切片</p><pre><code class="Go">[]bool{true, true, false}</code></pre><p>结构体和切片结合的例子</p><pre><code class="Go">s := []struct {        i int        b bool    }{        {2, true},        {3, false},        {5, true},        {7, true},        {11, false},        {13, true},    }</code></pre><p>切片的长度：包含的元素个数<br>切片的容量：从它包含的第一个元素开始，到其底层数组末尾的个数（倒是暂时不懂有什么用）</p><pre><code class="Go">s := []int{2, 3, 5, 7, 11, 13}len(s)    //6cap(s)    //6</code></pre><p>切片空 - nil</p><pre><code class="Go">var s []intfmt.Println(s, len(s), cap(s))if s == nil {    fmt.Println(&quot;nil!&quot;)}</code></pre><p>用make创建切片 - 相当于动态创建数组，初始值都为0</p><pre><code class="Go">a := make([]int, 5)  // len(a)=5b := make([]int, 0, 5) // len(b)=0, cap(b)=5</code></pre><p>切片中的切片以及修改的例子</p><pre><code class="Go">// Create a tic-tac-toe board.board := [][]string{    []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},    []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},    []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},}// The players take turns.board[0][0] = &quot;X&quot;board[2][2] = &quot;O&quot;board[1][2] = &quot;X&quot;board[1][0] = &quot;O&quot;board[0][2] = &quot;X&quot;// modify the first line (by myself)board[0] = board[0][0:1]board[0] = board[0][:cap(board[0])]</code></pre><p>向切片追加元素，注意：这个操作会导致底层数组被挤占，如果cap不够，会分配一个更大的数组</p><pre><code class="Go">var k = [5]int{1,2,3,4,5}    //k: [1 2 3 4 5]m := k[:3]    //m: [1 2 3]m = append(m, 200)    //m: [1 2 3 200]; k: [1 2 3 200 5]m = append(m, 300)    //m/k: [1 2 3 200 300]m = append(m, 400)    //m: [1 2 3 200 300 400]; k: [1 2 3 200 300]</code></pre><pre><code class="Go">var k = [5]int{1,2,3,4,5}    //k: [1 2 3 4 5]m := k[:3]    //m: [1 2 3]m = append(m, 200, 300, 400)    //m: [1 2 3 200 300 400]    //k: [1 2 3 4 5]</code></pre><p>Range遍历切片</p><pre><code class="Go">var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}func main() {    //index + value    for i, v := range pow {        fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)    }    //只有index (i)    for i := range pow {        pow[i] = 1 &lt;&lt; uint(i) // == 2**i    }    //只有value(value), index用_省略掉    for _, value := range pow {        fmt.Printf(&quot;%d\n&quot;, value)    }}</code></pre><p>Slice 练习 —— 构造给定长度的二维数组并绘图</p><pre><code class="Go">package mainimport &quot;golang.org/x/tour/pic&quot;func Pic(dx, dy int) [][]uint8 {    result := [][]uint8{}    for y := 0; y &lt; dy; y++ {        temp := []uint8{}        for x := 0; x &lt; dx; x++{            temp = append(temp,uint8((x+y)/2))        }        result = append(result, temp)    }    return result}func main() {    pic.Show(Pic)}</code></pre><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>一个例子 —— 基本类型</p><pre><code class="Go">k := make(map[string]int)k[&quot;hello&quot;] = 3fmt.Println(k[&quot;hello&quot;])</code></pre><p>另一个例子 —— 结构体</p><pre><code class="Go">type Vertex struct {    Lat, Long float64    Short float64}func main() {    m := make(map[string]Vertex)    m[&quot;Bell Labs&quot;] = Vertex{1,2,3}    fmt.Println(m[&quot;Bell Labs&quot;])}</code></pre><p>直接初始化</p><pre><code class="Go">type Vertex struct {    Lat, Long float64}var m = map[string]Vertex{    &quot;Bell Labs&quot;: Vertex{        40.68433, -74.39967,    },    &quot;Google&quot;: Vertex{        37.42202, -122.08408,    },    //倒也诡异，这里的&quot;,&quot;不能省略}//简化var m = map[string]Vertex{    &quot;Bell Labs&quot;: {40.68433, -74.39967},    &quot;Google&quot;:    {37.42202, -122.08408},}</code></pre><p>对映射的修改</p><pre><code class="Go">//在映射 m 中插入或修改元素：m[key] = elem//获取元素：/*        如元素不存在，则返回该元素类型的零值：    例如 int 返回 0, string 返回 &quot;&quot;*/elem := m[key]//获取并检测元素是否存在elem, ok := m[key]//只检测元素是否存在_, ok := m[key]//删除元素：delete(m, key)</code></pre><p>自创的和if复合使用</p><pre><code class="Go">if _,ok:=m[&quot;Answer&quot;];ok==true{}</code></pre><p>练习：单词检测</p><pre><code class="Go">package mainimport (    &quot;golang.org/x/tour/wc&quot;    &quot;strings&quot;)func WordCount(s string) map[string]int {    aMap := map[string]int{}    aArray := strings.Fields(s)    for _,v := range aArray{        aMap[v]++;    }    return aMap}func main() {    wc.Test(WordCount)}</code></pre><h2 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h2><pre><code class="Go">package mainimport (    &quot;fmt&quot;    &quot;math&quot;)//作为形式参数func compute(fn func(float64, float64) float64) float64 {    return fn(3, 4)}func main() {    hypot := func(x, y float64) float64 {        return math.Sqrt(x*x + y*y)    }    fmt.Println(hypot(5, 12))    //作为实际参数    fmt.Println(compute(hypot))    fmt.Println(compute(math.Pow))}</code></pre><h2 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h2><p>函数闭包指的是这样的“<strong>函数值</strong>”：该函数值代表的函数使用了函数体外（非全局）的函数；这样就使得这个函数某种意义上来说“附于”这个/这些变量（有种对象的感觉了，只不过这个对象只有一个方法）</p><pre><code class="Go">/*注意这里 adder 并不是一个函数闭包，adder()才是*/func adder() func(int) int {    sum := 0    return func(x int) int {        sum += x        return sum    }}func main() {    pos:= adder()    fmt.Println(pos(1))    fmt.Println(pos(100))}</code></pre><p>练习：斐波那契数列</p><pre><code class="Go">func fibonacci() func() int {    former := 0    latter := 1    return func() int {        temp := former        temp2 := latter        latter += former        former = temp2        return temp    }}func main() {    f := fibonacci()    for i := 0; i &lt; 10; i++ {        fmt.Println(f())    }}</code></pre><h1 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 没有类。不过你可以为结构体类型定义方法。方法就是一类带特殊的 接收者 参数的函数。</p><p>打个栗子</p><pre><code class="Go">import (    &quot;fmt&quot;    &quot;math&quot;)type Vertex struct {    X, Y float64}func (v Vertex) Abs() float64 {    return math.Sqrt(v.X*v.X + v.Y*v.Y)}func main() {    v := Vertex{3, 4}    fmt.Println(v.Abs())}</code></pre><p>为非结构体声明方法</p><pre><code class="Go">type MyFloat float64//直接为float64声明方法是非法的，因为它是包外的func (f MyFloat) Abs() float64 {    if f &lt; 0 {        return float64(-f)    }    return float64(f)}</code></pre><p>指针接收者：值得注意的是，如果用值接收者的话，方法是无法对这个接收者——天..还是叫对象吧——方法是无法对这个对象进行修改的，而指针接收者可以。</p><p>因此显然是指针接收者更为常用（我认为，要保护数据的时候就最好不用指针）</p><pre><code class="Go">func (v *Vertex) Scale(f float64) {    //如果不是*Vertex而是Vertex,这里修改对原对象无效    v.X = v.X * f    v.Y = v.Y * f}func main() {    v := Vertex{3, 4}    v.Scale(10)    fmt.Println(v.Abs())}</code></pre><p>使用指针接收者时，实际参数无论是对象还是对象的指针，最终都会转化为指针传给函数(而单纯的函数是做不到这一点的，是否指针很严格)</p><pre><code class="Go">func (v *Vertex) Scale(f float64) {    v.X = v.X * f    v.Y = v.Y * f}func main() {    v := Vertex{3, 4}    v.Scale(2)    p := &amp;Vertex{3, 4}    p.Scale(2)    fmt.Println(v, p)    //可以看到由于指针的重定向，两个方式调用方法起到了同样的效果}</code></pre><p>同样地，在方法声明里这样</p><pre><code class="Go">func (v Vertex) Scale(f float64)</code></pre><p>实参也是既可以是指针也可以是值，当然其区别就在于这种声明无法修改对象的值；</p><p><strong>总而言之，方法是否能修改对象，要看函数声明的形参，和实参没有关系</strong></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口类型的变量可以保存任何实现了这些方法的值</p><p>一个例子：</p><pre><code class="Go">type Abser interface {    Abs() float64}func main() {    var a Abser    f := MyFloat(-math.Sqrt2)    v := Vertex{3, 4}    a = f  // a MyFloat 实现了 Abser    a = &amp;v // a *Vertex 实现了 Abser    // 下面一行，v 是一个 Vertex（而不是 *Vertex）    // 所以没有实现 Abser。    //a = v    fmt.Println(a.Abs())}type MyFloat float64func (f MyFloat) Abs() float64 {    if f &lt; 0 {        return float64(-f)    }    return float64(f)}type Vertex struct {    X, Y float64}func (v *Vertex) Abs() float64 {    return math.Sqrt(v.X*v.X + v.Y*v.Y)}</code></pre><p><code>接口值</code>也是一个对象，包含了具体对象的值以及它的类型，可以用printf输出；<br><br>未赋值的接口值其对象值和类型都为<code>&lt;nil&gt;</code></p><pre><code class="Go">type I interface {    M()}type T struct {    S string}func (t T) M() {    fmt.Println(t.S)}func main() {    var i I    i = T{&quot;Hello&quot;}    describe(i)    i.M()    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)}/*结果：({Hello}, main.T)*/</code></pre><p>如果将某个类型的<code>nil</code>对象赋予某个接口，方法依然会被调用</p><pre><code class="Go">var t *Ti = tfmt.Printf(&quot;(%v, %T)\n&quot;, i, i)i.M()/*输出(&lt;nil&gt;, *main.T), 但M方法仍然会被调用*/</code></pre><p>对<code>nil</code>接口（注意不是和上面的<code>nil</code>对象值不同，这里是连类型都是<code>nil</code>）调用方法会panic</p><pre><code class="Go">var i Ii.M() //报错</code></pre><p>空接口的妙用：可以保存任意类型的值！（怎么有种Javascript的感觉了）</p><pre><code class="Go">var i interface{}i = 42i = &quot;hello&quot;</code></pre><p>类型断言：判断接口是不是某个类型，并且赋值</p><pre><code class="Go">var i interface{} = &quot;hello&quot;    //string 类型/* 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true */s, ok := i.(string)    fmt.Println(s, ok)/* 若 i 保存的不是一个 T，ok 将为 false 而 t 将为 T 类型的零值 */f, ok := i.(float64)fmt.Println(f, ok)/* 不是T，又没有OK =&gt; panic */f = i.(float64) fmt.Println(f)</code></pre><p>接口类型选择(switch)</p><pre><code class="Go">switch v := i.(type) {case int:    fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2)case string:    fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v))default:    fmt.Printf(&quot;I don&#39;t know about type %T!\n&quot;, v)}</code></pre><p><strong>Stringer</strong>类型，在<code>fmt</code>中的，是最普遍的接口之一。比如一个Print一个对象，默认会输出对象数据，但可以通过实现 <code>String()</code>方法改变输出</p><pre><code class="Go">type Person struct {    Name string    Age  int}func (p Person) String() string {    return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)}func main() {    a := Person{&quot;Arthur Dent&quot;, 42}    fmt.Println(a)}/*当前输出： Arthur Dent (42 years)如果不实现String()方法：{Arthur Dent 42}*/</code></pre><p>练习：输出IP地址。用到了fmt.Sprintf</p><pre><code class="Go">package mainimport &quot;fmt&quot;type IPAddr [4]byte// TODO: Add a &quot;String() string&quot; method to IPAddrfunc (i IPAddr) String() string{    var result string    result = fmt.Sprintf(&quot;%v.%v.%v.%v&quot;,i[0],i[1],i[2],i[3])    return result}func main() {    hosts := map[string]IPAddr{        &quot;loopback&quot;:  {127, 0, 0, 1},        &quot;googleDNS&quot;: {8, 8, 8, 8},    }    for name, ip := range hosts {        fmt.Printf(&quot;%v: %v\n&quot;, name, ip)    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
